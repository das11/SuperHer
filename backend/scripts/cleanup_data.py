"""
# Data Cleanup Script Walkthrough

I have created a comprehensive cleanup script to remove test data generated by the verification scripts (`verify_phase4.py`, `verify_phase5_stats.py`).

## Features
- **Time-Based Deletion**: Deletes data created within the last N hours (default: 24) to preserve older, manual data.
- **Dependency Handling**: Deletes data in the correct order (`Events` -> `Links/Coupons` -> `Associations` -> `Campaigns` -> `Advertisers`) to respect foreign key constraints.
- **Dry Run Mode**: Preview what will be deleted without changing the database.

## Usage

### 1. Dry Run (Preview)
Check what data would be deleted from the last 24 hours:
```bash
uv run python scripts/cleanup_data.py --dry-run
```

### 2. Execute Cleanup
Delete data from the last 24 hours:
```bash
uv run python scripts/cleanup_data.py
```

### 3. Custom Time Window
Delete data from the last 48 hours:
```bash
uv run python scripts/cleanup_data.py --hours 48
```

## Deleted Entities
The script targets the following tables, filtering by `created_at` or `timestamp`:
1. `click_events`
2. `customer_events`
3. `tracking_links`
4. `coupons`
5. `campaign_influencers` (associated with new campaigns)
6. `campaigns`
7. `api_keys`
8. `influencers`
9. `advertisers`
"""

import asyncio
import argparse
import sys
import os
from datetime import datetime, timedelta
from sqlalchemy import delete, select
from sqlalchemy.ext.asyncio import AsyncSession

# Add parent directory to path to allow imports from app
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.core.database import SessionLocal, engine
from app.models.advertiser import Advertiser, APIKey
from app.models.campaign import Campaign
from app.models.influencer import Influencer, campaign_influencer
from app.models.coupon import Coupon
from app.models.tracking_link import TrackingLink
from app.models.customer_event import CustomerEvent
from app.models.click_event import ClickEvent
from app.models.user import User

async def cleanup_data(hours: int, dry_run: bool):
    cutoff_time = datetime.utcnow() - timedelta(hours=hours)
    print(f"üßπ Cleanup Configuration:")
    print(f"   - Time Window: Past {hours} hours")
    print(f"   - Cutoff Time: {cutoff_time} (UTC)")
    print(f"   - Dry Run: {dry_run}")
    print("--------------------------------------------------")

    async with SessionLocal() as session:
        async with session.begin():
            # 1. Click Events (timestamp)
            stmt = delete(ClickEvent).where(ClickEvent.timestamp > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - ClickEvents: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 2. Customer Events (timestamp)
            stmt = delete(CustomerEvent).where(CustomerEvent.timestamp > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - CustomerEvents: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 3. Tracking Links (created_at)
            stmt = delete(TrackingLink).where(TrackingLink.created_at > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - TrackingLinks: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 4. Coupons (created_at)
            stmt = delete(Coupon).where(Coupon.created_at > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - Coupons: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 5. Campaign Influencers (Associative Table)
            # Delete if the campaign is created after cutoff OR influencer created after cutoff
            # For simplicity and safety in this script, we will target rows linked to campaigns created after cutoff
            # as that's the primary driver of new relationships in our test scripts.
            
            # Find campaigns to be deleted
            campaigns_query = select(Campaign.id).where(Campaign.created_at > cutoff_time)
            # Find influencers to be deleted
            influencers_query = select(Influencer.id).where(Influencer.created_at > cutoff_time)
            
            stmt = delete(campaign_influencer).where(
                (campaign_influencer.c.campaign_id.in_(campaigns_query)) |
                (campaign_influencer.c.influencer_id.in_(influencers_query))
            )
            result = await session.execute(stmt)
            print(f"   - CampaignInfluencers: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 6. Campaigns (created_at)
            stmt = delete(Campaign).where(Campaign.created_at > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - Campaigns: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 7. API Keys (created_at) - explicitly delete to avoid orphans if cascade misses or for clarity
            stmt = delete(APIKey).where(APIKey.created_at > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - APIKeys: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 7.5. Users (associated with new Advertisers or Influencers)
            # Find advertisers to be deleted
            advertisers_query = select(Advertiser.id).where(Advertiser.created_at > cutoff_time)
            # Find influencers to be deleted
            influencers_query = select(Influencer.id).where(Influencer.created_at > cutoff_time)
            
            stmt = delete(User).where(
                (User.advertiser_id.in_(advertisers_query)) |
                (User.influencer_id.in_(influencers_query))
            )
            result = await session.execute(stmt)
            print(f"   - Users: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 8. Influencers (created_at)
            stmt = delete(Influencer).where(Influencer.created_at > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - Influencers: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            # 9. Advertisers (created_at)
            stmt = delete(Advertiser).where(Advertiser.created_at > cutoff_time)
            result = await session.execute(stmt)
            print(f"   - Advertisers: {result.rowcount} rows {'would be ' if dry_run else ''}deleted")

            if dry_run:
                # Rollback everything in dry run
                await session.rollback()
                print("\nüö´ Dry run complete. No changes committed.")
            else:
                # Commit is automatic with session.begin context, assuming no exception
                print("\n‚úÖ Cleanup successful. Changes committed.")

async def main():
    parser = argparse.ArgumentParser(description="Cleanup test data from database.")
    parser.add_argument("--hours", type=int, default=24, help="Delete data created in the last N hours (default: 24)")
    parser.add_argument("--dry-run", action="store_true", help="Simulate deletion without committing")
    
    args = parser.parse_args()
    
    try:
        await cleanup_data(args.hours, args.dry_run)
    except Exception as e:
        print(f"\n‚ùå Error during cleanup: {e}")
    finally:
        await engine.dispose()

if __name__ == "__main__":
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    asyncio.run(main())
